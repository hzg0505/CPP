# c++

[学习代码](https://github.com/hzg0505/CPP.git)

## 第一课 c++ 简介

### 1. 为什么学 c++

- 性能  = 金钱

  - 耗电
  - 资源有限
  - 体验

- 开发效率低下、更长的开发周期、更高的工资  =?> 是不是更费钱

- 数据中心

  - 硬件 58%
  - 配电、降温  18%
  - 耗电 13%

- 编程语言需求

  - 效率
  - 灵活
  - 抽象
  - 生产力

  > c++ 注重前三者，java 注重后两项

- c++ 应用范围广泛

### 2. 为什么 c++ 难学

- c++ 之父  *The c++ programming language*
  - 更好的 c
  - 支持数据抽象
  - 支持面向对象
  - 支持面向泛型
- 支持的编程范式（paradiam）
  - 过程式
  - 数据抽象
  - 基于对象
  - 面向对象式
  - 函数式
  - 泛型形式
  - 模版元形式
- 值语义 与 对象语义
  - 值语义：可以拷贝和赋值
  - 对象语义：不可以拷贝和赋值

### 3. c++ 编程书籍推荐

- C++ primer

- Effective C++ 3rd
- C++ 编程规范
- 代码大全，第二版
- c++ 高质量编程  （不推荐、讲排版上的规范）

## 第二课 从 c 到 c++《一》

### 1. 数据类型

> 2023/const_demo.cpp

- bool

- const

  - const 定义的常量与 #define 定义的符号常量的区别
    - const 定义的有类型，#define 定义的没有类型。
    - const 在编译的时候分配内存， #define 在预编译时进行替换，不分配内存。
    - 作用域不同
  - 尽可能用 enum(枚举) 和 const 定义常量。
  - 高层次编程用 const enum inline 替换 #define
  - 在底层编程时，#define 是很灵活的

  > 2023/define_demo.cpp

<img src="/Users/hzg/Library/Application Support/typora-user-images/image-20230307203135308.png" alt="image-20230307203135308" style="zoom:50%;" />

<img src="/Users/hzg/Library/Application Support/typora-user-images/image-20230307204642003.png" alt="image-20230307204642003" style="zoom:50%;" />

### 2. 结构体对齐

> 2023/struct_align.cpp

### 3. 域运算符 ::

- c++ 中增加作用域标识符 ::

  - 用于访问对与局部变量同名的全局变量
  - 用于访问类的成员

  > 2023/field_demo.cpp

### 4. new & delete 运算符

> 2023/new_and_delete.cpp

- **new** 运算符可用于创建堆空间（c语言中的 malloc）
  - 成功返回首地址
  - 失败抛出异常
  - 语法
    - 指针变量 = new 数据类型；
    - 指针变量 = new 数据类型[长度 n]；创建n个数据类型的元素
- **delete** 运算符 用于释放堆空间 （c语言中的 free）
  - 语法
    - delete 指针变量；
    - delete[] 指针变量
- 对象
  - new 一个新的对象 （new operator）
    - 内存分配(operator new)   => malloc 只进行内存分配
    - 构造函数
  - delete 释放一个对象
    - 调用析构函数
    - 释放内存(operator delete)

- new 的用法
  - operator new  ：只分配内存
  - new operator ：分配内存+调用构造函数
  - placement new：不分配内存，只调用拷贝构造函数

### 5. 重载

> 2023/overload_demo.cpp

- **相同的作用域**、两个函数名称相同、参数不同  => 重载 overload

- 函数重载 又称 函数多态性

  - 静态的多态：编译时已经确定函数入口地址（静态联编）

    > 动态多态表现为派生类，虚函数实现：在运行时确定函数入口地址（动态联编）

- 函数重载不同形式

  - 形参数量不同
  - 形参类型不同
  - 形参顺序不同
  - 形参数量和形参类型均不同 

- 调用重载函数时，编译器通过检查实际参数的个数、类型和顺序来确定相应的被调函数

<img src="/Users/hzg/Library/Application Support/typora-user-images/image-20230307221513972.png" alt="image-20230307221513972" style="zoom:50%;" />

![image-20230307221826240](/Users/hzg/Library/Application Support/typora-user-images/image-20230307221826240.png)

- extern "C" 表示不进行名字改编		 

### 6. 带默认形参值的函数

- 函数没有声明时，在函数定义时指定形参的默认值
- 函数既有定义又有声明时，声明时指定后，定义后就不能再指定默认值
- 默认值定义必须遵循从右到左的顺序

- 函数调用时，实参与形参从左到右进行匹配

> 2023/default_par.cpp

## 第三课 从 c 到 c++《二》

### 1. 引用

> 2023/ref_demo.cpp

- 引用是给一个变量起别名
  - 变量属性
    - 名称
    - 空间
  - 引用不是变量，只是变量的别名，没有自己独立的空间，要与所引用的变量共享空间
  - 对引用所做出的改变就是对引用的变量所做出的改变
- 引用定义时必须初始化
- 引用经过初始化后就不能重新指向其他变量

### 2. const 引用

>  2023/const_ref.cpp

- const 引用是指向 const 对象的引用
- 不能用普通引用指向 const 对象
- 可以用const引用指向 普通对象, 此时不能通过引用更改
- 非 const 引用无法指向不同类型的对象

### 3. 引用传递

> 2023/ref_func.cpp.  2023/ref_loc_val.cpp.  2023/ref_val_trans.cpp

- 按引用传递
- 引用传递方式是在函数定义时在形参前面加上引用运算符“&”
- 引用作为参数传递
  - c语言
    - 值传递 ：形参不能更改实参
    - 指针传递（地址传递）：形参值的改变能够改变相应的实参
  - 引用传递
    - 形参值的改变能够改变相应的实参
- 引用作为函数返回值
  - 在函数返回时初始化
  - 不能返回局部变量的引用

### 4. 引用和指针的区别

- 引用
  - 访问变量是直接访问
  - 引用是变量的别名，没有自己的内存空间。通过替换
  - 初始化后不能再引用其他变量
- 指针
  - 访问变量是间接访问
  - 指针有自己的内存空间。指针本身具有 4 bit（32位系统），保存的是指向变量的地址 
  - 初始化后仍可以指向其他变量

> 尽可能使用引用，不得已才使用指针

- 值传递：实参初始化形参需分配内存空间， 讲实参内容拷贝到形参
- 引用传递：实参初始化形参不分配空间。效率较高
- 指针传递：本质上是值传递，如果需要修改指针的地址，不能简单地进行指针传递，需要指针的指针 **，或者指针的引用 *&

## 第四课 从 c 到 c++《三》

### 1. 内联函数

- 当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序执行的转移等等。需要系统时间和空间的开销。
- 当函数较为简单，同时又频繁调用，会使得程序执行效率低。
- 解决方法
  - 不执行函数，直接讲函数代码嵌入到程序中	 =》 代码重复书写，可读性低
  - 内联函数 inline 修饰
    - 替换工作由编译器完成

### 2. 内联函数与带参数的宏区别

<img src="/Users/hzg/Library/Application Support/typora-user-images/image-20230308160937573.png" alt="image-20230308160937573" style="zoom:50%;" />

- 内联函数调用时，要求实参和形参的类型一致
- 内联函数会先对实参表达式进行求值，然后传递给形参；宏调用时只用实参简单的替换形参

- 内联函数是在编译时将代码展开，宏是在预处理时替换
- c++ 中建议使用内联函数来替换带参数的宏



### 3. 新的类型转换运算符

> 2023/const_cast_demo.cpp.     2023/static_cast_demo.cpp

- c 中

  - （T）expr
  - T（expr）

- c++ 中新的类型转换方法

  - const_cast<T>(expr)
    - 移除对象的常量性
    - 一般用于指针或者引用
    - 使用 const_cast 去除常量性 目的不是为了修改常量的值，通常是为了让函数能够接受这个实际参数
  - static_cast<T>(expr)
    - 编译器隐式执行的任何类型的转换都可由 static_cast 完成
      - 不是编译器隐式执行的类型转换就是显式转换
      - 隐式转换不需要用显式转换来完成
    - 较大的算术类型赋值给较小的类型时，可以用 static_cast 进行强制转换
    - 可以将 void* 类型指针转换为某一类型的指针 
    - 可以将基类指针转换为派生类指针
    - 无法将 const 转化为 noconst
  - reinterpret_cast<T>(expr)
    - 以二进制的方式重新解释
  - dynamic_cast<T>(expr)
    - 不能用旧式语法进行转型
    - 一般用在派生类和基类之间的转型操作

  > 尽可能避免使用强制类型转换（显示）



## 第五课 面向对象介绍

### 1. 结构化程序设计

- 程序

  - 程序是按照一定的逻辑来处理数据

  - pascal之父   结构化程序设计先驱   迪杰斯特拉
    - 程序  = 算法 + 数据结构

  - 程序是完成一定功能的一系列有序指令的集合
    - 指令 = 操作码 + 操作数

- 语言

  - 机器语言
    - 机器能读懂的语言，二进制指令集合

  - 汇编语言
    - 将机器指令映射为一些可以被人读懂的助记符

  - 高级语言
    - 屏蔽了机器的细节，提高了语言的抽象层次

- 机器语言和汇编语言是在机器的角度考虑问题，代码和数据的界限模糊

- 结构化程序设计

  - 自顶向下

  - 程序  = 算法 + 数据结构

  - 将程序分为不同的模块，使得整个程序更加具有条理性

  - 多数数据仍属于整个程序，具有许多全局变量，在某些地方更改可能会影响其他地方

  - 考虑问题以算法为中心，不以数据为中心

  - 要求软件负责人了解整个任务分解

  - 缺陷

    - 程序难以管理
    - 数据修改存在问题
    - 程序可重用性差

    - 用户要求难以在系统分析阶段准确定义，致使系统在交付阶段存在许多问题
    - 用系统开发每个阶段的成果来进行控制，不能适应事物变化的要求，
    - 不适合大型软件的开发

### 2. 面向对象程序设计

- 将系统看作是通过交互来完成特定功能的对象的集合。每个对象用自己的方法来管理数据	
  - 程序 = 对象 +...+ 对象  + 	数据交互
  - 对象 = 算法 + 数据结构 （封装思想）
  - 以对象为中心
  - 同类对象可以抽象出共性（类）
    - 类中的数据通常通过本类中的方法进行处理
    - 类中的方法成为与外部的接口
    - 对象之间通过消息进行通讯
- 特征
  - 抽象
  - 封装
  - 继承
  - 多态
- 数据抽象
  -  结构化程序设计是对过程的抽象，以算法（过程）为中心	
    - 将共同的操作抽取出来，看成一个实体
  - 面向对象是数据抽象，是更高级的抽象
    - 将描述客体的属性和行为进行绑定，实现统一的抽象

### 3. 从计算机的观点看对象

- 对象是计算机内存中的一块区域，通过内存分块，每个对象在功能上相对保持独立。
- 内存不仅存储数据，还存储代码。保证对象是受保护的，只有对象中的代码能访问存储于对象中的数据。

- 对象之间只能通过函数调用来发送消息实现相互通信。
- 对象的一个函数被调用时，对象执行内部代码来响应该调用，从而呈现一定的行为

### 4. 抽象

- 抽象是人们认识事物的一种方法
- 抓住事物本质，而不是内部具体细节或具体实现
- 抽象：从具体到一般的一个过程
- 对象 => 类（归类）  

### 5. 封装

- 按照信息屏蔽的原则，把对象的属性和操作结合在一起，构成独立的对象
- 通过限制对属性和操作的访问权限，可以将属性隐藏在对象内部，对外提供一定的接口，在对象之外只能通过一定的接口对对象进行操作
- 封装增加了对象的独立性，从而保证了对象的可靠性
- 外部对象不能直接操作对象的属性，只能使用对象提供的服务

### 6. 继承

- 继承表达了对象的一般与特殊的关系。特殊类的对象具有一般类的全部属性和服务。
- （大类）=> （小类）新类中只需描述自己所特有的属性和操作
- 继承简化了对问题的描述。提高了程序的复用性，提高了程序设计、修改、扩充的效率。

### 7. 多态

- 多态性：同一个消息被不同的对象接收时，产生不同的结果。即实现同一接口，不同方法。
- 一般类中定义的属性和方法，在特殊类中不改变其名字，但通过各自不同的实现后，可以具有不同的数据类型或有不同的行为。

> 继承和多态性的结合，可以生成很多相似但又独一无二的对象。继承性使得这些对象可以共享许多相似特性，而多态又使得同一操作对不同对象产生不同的表现形式。提高了程序设计灵活性，减轻了分别设计的负担。

### 8.  面向对象程序设计思想

- 面向对象是一种程序设计方法，也是一种认识世界的方法
- 客观世界 =》 实体  =〉 对象组成的
- 对象
  - 内部状态（静态）
  - 运动规律（动态）
- 对象之间的联系构成了不同的系统

### 9. 面向对象编程

- 面向对象编程方法的特性
  - 重点在数据而不是函数
  - 不是完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为
  - 对象之间通过相互协作来完成功能
  - 函数与相关数据紧密结合
  - 数据可以被隐藏
  - 很容易扩充新的数据和函数
  - 开闭原则：对增加开放，对修改、删除关闭
- 优点
  - 易维护：可读性高，即使改变需求，由于继承的存在，维护也只是在局部模块
  - 质量高：可重用已被测试的类
  - 效率高
  - 易扩展
- 缺点
  - 运行效率会下降10%左右

## 第六课 类与对象

> 2023/class_demo.   2023/class_clock_demo.cpp.  2023/class_clock_demo_2.cpp

### 1. 类定义

- 类声明

```c++
class 类名
{
  public:
  	// 公有成员（外部接口）
      int a;
  protected:
    // 保护成员
  private:
  	// 私有成员
};
```

- 公有、私有、保护成员
  - public
    - 类与外部的接口，外部可访问公有类型数据和函数
  - private 
    - 只允许本类中的函数
  - protected
    - 继承和派生类可访问，其他类似private

### 2. 抽象与封装

- 数据抽象
  - 接口和实现分离
  - 类设计者：如何实现
  - 使用类程序员：不需要了解类实现细节，只需知道类能做什么
- 封装
  - 将低层次的元素组合	=》 新的、高层次实体
  - 函数封装
  - 类封装

### 3. 内联函数

> 2023/class_inline.cpp

- 编译的时候直接将代码嵌入到调用的地方，从而减少了函数调用的开销。
- 体积增大，空间换时间
- 表现形式
  - 直接在类体中给出成员函数代码，不在外部定义，内联成员函数
  - 声明时可以不用给出inline 关键字， 实现时给出 inline 关键字
- 常常较为短小，如果有switch、for，编译器可能不会将其按内联函数解析

### 4. 成员函数重载

- class_overload.cpp

- 类与结构体
  - 区别：在未指定访问权限时，class 默认是private， struct 默认是 public
  - class_struct.cpp

> 2023/class_overload.cpp\class_struct.cpp

### 5. 隐含的 this 指针

- 在定义一个对象时会分配内存，同一个类中定义了多个对象，
- 成员函数有一个隐含的附加形参，指向该对象的指针，叫做this指针
- 在访问成员函数时成员函数共享，通过隐含的 this  指针确定对象
- **this 指针保证了不同的对象能够拥有不同的数据成员，但处理这些成员的代码可以被所有对象共享**。
- this 指针指向了构造的对象, 使得成员函数能对相应的对象进行操作

```c++
void Init(int m_x, int m_y, int m_z);
// =>
t1.Init(1, 2, 3);
t2.Init(10, 20, 30;

// =>
t1.Init(&t1, 1, 2, 3);
t2.Init(&t2, 10, 20, 30);      
```

### 6. 类作用域

> 2023/class_domain.cpp

- 每个类都定义了自己的作用域称为类作用域
- 类作用域中的标识符只在类内可见
- 作用域
  - 块作用域 ：{} 内
  - 文件作用域
  - 函数原型作用域
  - 函数作用域
  - 类作用域

### 7. 前向声明

> 2023/class_cross_ref

- c++ 中的类必须先定义才能实例化
- 当两个类相互引用出现环形引用时，无法先定义使用。这时候需要用到前向声明。
  - 类A：初始化类B
  - 类B：初始化类A

### 8. 嵌套类

> 2023/class_inter_outer.cpp

- 外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只用于外围类的实现，且同时可以对用户隐藏该底层类实现。
- 作用域：嵌套类被隐藏在外围类之中
- 嵌套类的成员函数可以在类体外定义，需加作用域
- 嵌套类中的成员函数对外围类中的私有成员没有权限访问，反之亦然

### 9. 局部类

> 2023/class_local.cpp

- 类也可以定义在函数体内，这种类称为局部类，局部类只在定义他的局部域可见
- 局部域的成员函数必须定义在类体中
- 局部类不能有静态成员。

> 2023/class_local.cpp

## 第七课 构造函数和析构函数

### 1. 构造函数

> 2023/constructor_demo.cpp.     2023/constructor_global.cpp.  2023/constructor_arr.cpp. 

- 构造函数是特有的成员函数
- 创建对象时系统会自动调用构造函数
- 保证每个数据成员正确初始化
- 定义规则
  - 函数名称和类名完全相同
  - 不能定义构造函数的类型（返回类型）
  - 通常应该声明为公有成员函数，否则不能像其他成员函数那样显示调用
    - 私有声明有特殊用途
  - 一个类可以有多个构造函数（函数重载）
- 全局对象的构造先于 main 函数

- 默认构造函数

  - 不带参数的构造函数称为默认构造函数

  - 如何类不提供任何构造函数，系统会提供一个不带参数的构造函数，如果定义了，系统将不自动提供默认构造函数

- new

  - 不仅申请了内存，还调用构造函数

### 2. 析构函数

- 析构函数不能被重载，没有参数
- 函数名和类名相似，多一个`~`：取反
- 没有返回类型，没有参数
- 如果没有定义析构函数，编译器会默认生成一个析构函数
- 默认析构函数是一个空函数
- delete
  - 不仅释放了内存，还调用了析构函数
- 析构函数的显示调用
  - 不推荐，一般很少用
  - 如果析构函数中有对数据处理，会进行多次处理

### 3. 转换构造函数

> 2023/tran_constructor.cpp

- 构造函数功能
  - 初始化
  - 类型转化（转换构造函数）
- 赋值和初始化的区别
  - 将整数赋值给类对象
    - 先初始化一个对象，再进行赋值，
    - 赋值过程重载了 “=”
- explicit
  - 只提供给类的构造函数使用的关键字、
  - 编译器不会把声明为 explicit 的构造函数用于隐式转换，它只能在程序代码中显示创建对象
  - 只能显示构造
  - Test t=30；不再等价于 Test t(30);

### 4. 构造函数初始化列表